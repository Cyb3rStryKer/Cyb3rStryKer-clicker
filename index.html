    // Sauvegarde l'Ã©tat actuel dans Firestore
    function saveUserGameData() {
      if (!currentUser || !userDocRef) return;
      userDocRef.update({
        credits,
        level,
        xp,
        xpForNextLevel,
        clickValue,
        boosters,
        inventory,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });
    }

    // === UI Updates ===
    function updateCreditsDisplay() {
      creditsDisplay.textContent = `${credits} $`;
    }

    function updateLevelDisplay() {
      levelDisplay.textContent = level;
    }

    function updateXpBar() {
      const percent = Math.min(100, Math.round((xp / xpForNextLevel) * 100));
      xpBarFill.style.width = percent + '%';
      xpText.textContent = `${xp} / ${xpForNextLevel}`;
    }

    function updateInventoryDisplay() {
      inventoryList.innerHTML = '';
      const keys = Object.keys(inventory);
      if (keys.length === 0) {
        inventoryList.textContent = "Inventaire vide";
        return;
      }
      keys.forEach(item => {
        const div = document.createElement('div');
        div.className = 'inventory-item';
        div.textContent = `${item} x${inventory[item]}`;
        inventoryList.appendChild(div);
      });
    }

    // === Click logique ===
    clickBagBtn.addEventListener('click', () => {
      credits += clickValue;
      xp += 10;

      sounds.click.play();
      clickBagBtn.classList.add('pop');

      if (xp >= xpForNextLevel) {
        xp -= xpForNextLevel;
        level++;
        xpForNextLevel = Math.floor(xpForNextLevel * 1.25);
        message.textContent = "Niveau supÃ©rieur ! ðŸŽ‰";
        setTimeout(() => message.textContent = '', 2000);
      }

      updateCreditsDisplay();
      updateLevelDisplay();
      updateXpBar();
      saveUserGameData();

      setTimeout(() => clickBagBtn.classList.remove('pop'), 300);
    });

    // === Boosters ===
    function renderBoosters() {
      boostersContainer.innerHTML = '';
      boosters.forEach((booster, index) => {
        const btn = document.createElement('button');
        btn.textContent = `${booster.name} (${booster.price}$)`;
        btn.addEventListener('click', () => {
          if (credits >= booster.price) {
            credits -= booster.price;
            booster.owned += 1;
            clickValue *= booster.multiplier;
            updateCreditsDisplay();
            message.textContent = `${booster.name} achetÃ© !`;
            sounds.cash.play();
            saveUserGameData();
          } else {
            message.textContent = "Pas assez de crÃ©dits !";
            sounds.error.play();
          }
          setTimeout(() => message.textContent = '', 2000);
        });
        boostersContainer.appendChild(btn);
      });
    }

    // === BoÃ®te MystÃ¨re ===
    buyBoxBtn.addEventListener('click', () => {
      if (credits < 20) {
        message.textContent = "Pas assez de crÃ©dits pour acheter une caisse.";
        sounds.error.play();
        setTimeout(() => message.textContent = '', 2000);
        return;
      }

      credits -= 20;

      const fruit = getRandomFruit();
      inventory[fruit.name] = (inventory[fruit.name] || 0) + 1;

      message.textContent = `ðŸŽ Vous avez gagnÃ© : ${fruit.name} (${fruit.rarity}) !`;
      sounds[fruit.sound].play();

      updateCreditsDisplay();
      updateInventoryDisplay();
      saveUserGameData();

      setTimeout(() => message.textContent = '', 3000);
    });

    function getRandomFruit() {
      const rand = Math.random();
      if (rand < 0.4) return fruits[Math.floor(Math.random() * 2)];            // Commun
      if (rand < 0.7) return fruits[2 + Math.floor(Math.random() * 2)];        // Rare
      if (rand < 0.9) return fruits[4 + Math.floor(Math.random() * 2)];        // TrÃ¨s Rare
      if (rand < 0.98) return fruits[6 + Math.floor(Math.random() * 2)];       // Mythique
      return fruits[8 + Math.floor(Math.random() * 2)];                        // LÃ©gendaire
    }

    // === Leaderboard en temps rÃ©el ===
    function initLeaderboardListener() {
      leaderboardUnsubscribe = db.collection('players')
        .orderBy('credits', 'desc')
        .limit(10)
        .onSnapshot(snapshot => {
          leaderboardList.innerHTML = '';
          snapshot.forEach(doc => {
            const data = doc.data();
            const li = document.createElement('li');
            li.innerHTML = `<span>${data.email}</span><span>${data.credits} $</span>`;
            leaderboardList.appendChild(li);
          });
        });
    }
  </script>
</body>
      </html>
        
